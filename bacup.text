//HOMEWORK #1 --- console checkers
class MoveStatus;
class Tile;
class TileModel;
enum Color {
    BLACK = 1, WHITE = -1
};
class Piece {
private:
    int _x;
    int _y;
    Color _color;
public:
    Piece(int y, int x, Color c) : _x(x), _y(y), _color(c) {};
    void setColor(Color c) { _color = c; }
    int getColor() { return _color; }
    int getY() const { return _y; }
    int getX() const { return _x; }
    void setY(int y) { _y = y; }
    void setX(int x) { _x = x; }
    virtual MoveStatus move(vector<vector<Tile>>, int, int) = 0;
    virtual void print() = 0;
};
class Tile {
private:
    Piece *_piece;
public:
    Tile() { this->_piece = nullptr; }
    void setPiece(Piece *piece) { _piece = piece; }
    Piece *getPiece() const { return _piece; }
    bool hasPiece() { return this->_piece != nullptr; }
};
enum MoveType {
    NONE, NORMAL, KILL
};
class MoveStatus {
private:
    MoveType _type;
public:
    MoveType getType() const { return _type; }

private:
    Piece *_piece{};
public:
    Piece *getPiece() const { return this->_piece; };

    MoveStatus(MoveType type) { this->_type = type; };

    MoveStatus(MoveType type, Piece *piece) {
        this->_type = type;
        this->_piece = piece;
    };
};
class Checker : public Piece {
    using Piece::Piece;
public:
    ~Checker() = default;
    MoveStatus move(vector<vector<Tile>> tiles, int new_y, int new_x) override {
        if (tiles[new_y][new_x].hasPiece() || (new_y + new_x) % 2 == 0) {
            return {NONE};
        }
        int y0 = this->getY();
        int x0 = this->getX();
        if (new_y - y0 == (int) (this->getColor()) && abs(new_x - x0) == 1)
            return {NORMAL};
        else if (new_y - y0 == (int) (this->getColor()) * 2 && abs(new_x - x0) == 2) {
            int other_y = y0 + (new_y - y0) / 2;
            int other_x = x0 + (new_x - x0) / 2;
            if (tiles[other_y][other_x].hasPiece() &&
                tiles[other_y][other_x].getPiece()->getColor() != this->getColor()) {
                return {KILL, tiles[other_y][other_x].getPiece()};
            }
        }
        return {NONE};
    }
    void print() override {
        if (this->getColor() == Color(-1))
            std::cout << "w ";
        else
            std::cout << "b ";
    }
};
class Queen : public Piece {
    using Piece::Piece;
public:
    Queen(int y, int x, Color c) : Piece(y, x, c) {}

    ~Queen() = default;

    void print() override {
        if (this->getColor() == Color(-1))
            std::cout << "W ";
        else
            std::cout << "B ";
    }

    MoveStatus move(std::vector<std::vector<Tile>> tiles, int newY, int newX) override {

        if (tiles[newY][newX].hasPiece() || (newX + newY) % 2 == 0) {
            return {NONE};
        }

        int qy = this->getY();
        int qx = this->getX();
        bool isPieceOnWay = false;

        if (abs(newY - qy) == abs(newX - qx)) {
            Piece *piece = checkDiagonal(tiles, qy, qx, newY, newX);
            if (piece != nullptr && piece->getColor() != tiles[qy][qx].getPiece()->getColor()) {
                isPieceOnWay = true;
            }
            if (isPieceOnWay) {
                return {KILL, piece};
            }

            return {NORMAL};
        } else return {NONE};

    }

    static Piece *checkDiagonal(std::vector<std::vector<Tile>> tiles, int oldY, int oldX, int newY, int newX) {
        if (newX - oldX > 0 && newY - oldY < 0) {
            for (int y = oldY - 1, x = oldX + 1; y > newY && x < newX; x++, y--) {
                if (tiles[y][x].hasPiece()) {
                    return tiles[y][x].getPiece();
                }
            }
        }
        if (newX - oldX < 0 && newY - oldY > 0) {
            for (int y = oldY + 1, x = oldX - 1; y < newY && x > newX; x--, y++) {
                if (tiles[y][x].hasPiece()) {
                    return tiles[y][x].getPiece();
                }
            }
        }
        if (newX - oldX < 0 && newY - oldY < 0) {
            for (int y = oldY - 1, x = oldX - 1; y > newY && x > newX; x--, y--) {
                if (tiles[y][x].hasPiece()) {
                    return tiles[y][x].getPiece();
                }
            }
        }
        if (newX - oldX > 0 && newY - oldY > 0) {
            for (int y = oldY + 1, x = oldX + 1; y < newY && x < newX; x++, y++) {
                if (tiles[y][x].hasPiece()) {
                    return tiles[y][x].getPiece();
                }
            }
        }
        return nullptr;
    }


};
const char row[] = "ABCDEFGH";
class Board {
private:
    mutable vector<vector<Tile>> _tiles;
    int _blackCounter;
    int _whiteCounter;
    int _playerTurn;

public:
    ~Board() = default;

    Board() {
        for (int y = 0; y < 8; y++) {
            std::vector<Tile> v1;
            v1.reserve(8);
            for (int x = 0; x < 8; x++) {
                v1.emplace_back();
            }
            _tiles.push_back(v1);
        }

        this->_whiteCounter = 0;
        this->_blackCounter = 0;

        for (int y = 5; y < 8; y++) {
            for (int x = 0; x < 8; x++) {
                if ((y + x) % 2) {
                    this->_tiles[y][x].setPiece(new Checker(y, x, Color(-1)));
                    this->_whiteCounter++;
                }
            }
        }

        for (int y = 0; y < 3; y++) {
            for (int x = 0; x < 8; x++) {
                if ((y + x) % 2) {
                    this->_tiles[y][x].setPiece(new Checker(y, x, Color(1)));
                    this->_blackCounter++;
                }
            }
        }

        _playerTurn = -1;
    }

    bool checkWinCondition() const {

        if (_blackCounter == 0) {
            std::cout << "White player wins" << std::endl;
            return true;
        } else if (_whiteCounter == 0) {
            std::cout << "Black player wins" << std::endl;
            return true;
        } else
            return false;

    }

    int getWhiteCounter() const { return _whiteCounter; }

    int getBlackCounter() const { return _blackCounter; }

    void tryMove(int old_number, char old_letter, int new_number, char new_letter) {
        int oldY = int(old_number) - 1, oldX = 0;
        int newY = int(new_number) - 1, newX = 0;
        int j = 0;
        for (char i: row) {
            if (i == old_letter)
                oldX = j;
            ++j;
        }
        j = 0;
        for (char i: row) {
            if (i == new_letter)
                newX = j;
            ++j;
        }

        MoveStatus moveStatus = NONE;

        if (_tiles[oldY][oldX].hasPiece() && !_tiles[newY][newX].hasPiece() &&
            _playerTurn == _tiles[oldY][oldX].getPiece()->getColor()) {
            moveStatus = _tiles[oldY][oldX].getPiece()->move(_tiles, newY, newX);
            if (moveStatus.getType() != NONE) {
                if (_playerTurn == 1)
                    _playerTurn = -1;
                else
                    _playerTurn = 1;
            } else {
                std::cout << "Wrong position!" << std::endl;
            }
        }


        switch (moveStatus.getType()) {

            case NONE:
                break;
            case NORMAL: {
                Piece *piece = _tiles[oldY][oldX].getPiece();
                piece->setY(newY);
                piece->setX(newX);

                if ((piece->getColor() == 1 && newY == 7) || (piece->getColor() == -1 && newY == 0)) {
                    int color = piece->getColor();
                    _tiles[newY][newX].setPiece(new Queen(newY, newX, Color(color)));
                } else
                    _tiles[newY][newX].setPiece(piece);

                _tiles[oldY][oldX].setPiece(nullptr);
                break;
            }

            case KILL:
                Piece *piece = _tiles[oldY][oldX].getPiece();
                piece->setY(newY);
                piece->setX(newX);
                if ((piece->getColor() == 1 && newY == 7) || (piece->getColor() == -1 && newY == 0)) {
                    int color = piece->getColor();
                    _tiles[newY][newX].setPiece(new Queen(newY, newX, Color(color)));
                } else
                    _tiles[newY][newX].setPiece(piece);
                _tiles[oldY][oldX].setPiece(nullptr);

                Piece *otherPiece = moveStatus.getPiece();
                _tiles[otherPiece->getY()][otherPiece->getX()].setPiece(nullptr);

                if (piece->getColor() == 1)
                    this->_whiteCounter--;
                else
                    this->_blackCounter--;

                break;
        }
    }


    void printBoard() const {
        for (int y = 0; y < 8; y++) {
            std::cout << y + 1 << " ";
            for (int x = 0; x < 8; x++) {
                if (_tiles[y][x].hasPiece())
                    _tiles[y][x].getPiece()->print();
                else if (!_tiles[y][x].hasPiece() && (x + y) % 2)
                    std::cout << ". ";
                else
                    std::cout << "  ";
            }
            std::cout << std::endl;
        }
        std::cout << "  ";

        for (int x = 0; x < 8; x++) {
            std::cout << row[x] << " ";
        }
    }

    int getPlayerTurn() const { return _playerTurn; }
};